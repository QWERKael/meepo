meepo是一个分布式的任务式运维工具
核心是分布式管理系统、任务系统和插件系统

渊源
我之前写过一个atk_D_class工具，meepo是他的进化版

分布式管理系统
可以使用gossip
任务和插件系统可以在atk_D_class的基础上修改

Go + Lua
大部分的功能模块由Go编写，包括通过plugin形式扩展的功能模块
通过内置的Lua虚拟机，可以动态的执行Lua脚本，使用动态的Lua脚本串联起来各个功能模块，从而实现taskchain的构想

~~taskchain~~
~~taskchain是meepo的一个基础执行单元~~

用gossip实现去中心化的服务
只有一个统一的服务器端的主程序
客户端通过服务器端加上一个用户友好的输入插件来实现
集群中的不同节点分成不同的角色，比如，服务端和客户端
gossip更多扮演的是发现者的角色
使用gossip同步集群中节点的列表，具体的通信采用p2p的方式

早期的测试阶段可以使用命令行参数的形式作为客户端的输入方式

实际使用的过程中，可以在机器上起一个服务端，然后每次执行命令的时候，用命令行的命令连接到本地的服务端来接入集群网络，再下发命令

meepo默认是客户端的命令，使用`--server`参数启动服务端

meepo里会存在有哪些消息？
集群节点列表（需要保持同步）
传输的命令消息（不需要保持同步）


gossip可不可以做广播但不存储？
因为我只需要通过广播下发命令，但是不需要将历史命令做全量同步，这样怎么来应付延时的问题呢？
因为有些命令是有时效性的，A命令发布后迟迟收不到回复，我将A命令取消了，执行B命令，而A和B命令是冲突的。
涉及到两个问题，gossip能不能保证按照顺序接收到命令，gossip有没有超时机制

最简单的方法还是只是用gossip做集群节点列表的维护，而不进行命令的发布与接受。可以将gossip作为一个插件使用。

meepo的重点功能：
进行较复杂的多节点联合任务的执行
实现目标：
1. 单任务发往单节点执行
2. 单任务发往多节点执行
3. 将不同任务分别发送给不同节点分别执行
4. 将不同任务分别发送给不同节点有依赖有顺序的执行

中心化和去中心化：
中心化的好处是连接的设计比较简单，所有的节点都向中心连接就可以了
如果是去中心化，怎么去设计呢？

gossip，或者说说有的已执行算法包括raft、paxos都是做分布式数据同步的

使用gossip从整个集群获取资源
每个服务器将自己的资源列表通过gossip上报并同步到整个集群，当一个节点需要什么资源的时候就可以从整个集群获取到该资源了

回到最开始也是最关键的问题，我可不可以通过gossip的广播来发布命令？
我觉得有的命令可以通过广播来发布
比如，我有100个节点，我需要找到3个磁盘空间大于1T的节点部署数据库服务，我可以通过广播来查询空间大于1T的节点，因为这种任务不需要实时，也不需要所有的节点都必须收到，即使有的节点没有收到或者有很大的延迟也没有关系，因为我不需要用到全部的节点，即便如此在他们检查完自己的磁盘空间进行反馈的时候也最好需要一种更安全和即是的方式进行反馈。
但是有些任务并不适合这种广播的形式进行发布，比如我要搭建数据库，我发布的命令

我希望的通信形式
node A将任务发送给node B，node B接收到任务后即返回状态ok，并不需要node B返回执行局结果，任务被存储在node B的任务管理器中，有任务管理器调度（任务可能被单次调用，循环调用，定时调用，排队调用），任务完成后将结果返回给node A即可。这种形式并不相识grpc中的远程调用或者stream，它更像是一种mail的形式，这不就是actor模型吗？


protoactor-go
我有看了看这个go语言的actor库，他有三种模式，local、remote、cluster
我以为我需要的是cluster模式，因为它实现了集群的功能，但是它没有继承memberlist
不过我研究了一下example只有，我发现我用不上cluster模式，cluster模式下将所有的node都当做是一样的node去使用，进行广播，进行计算
但是，我只需要使用集群去管理节点列表，我其实用不上cluster
本质上我还是用memberlist维护node list，使用remote进行一对一的调用

使用lua调用protoactor-go的remote
现在还有个问题，怎么使用lua调用remote，是需要将remote的调用写到plugin里吗

初步完成了actor通信功能，现在还有两个问题，一个是gossip集群，而gossip集群的实现已经决定采用plugin的形式了，另一个问题就是怎么去调用plugin，具体的说，就是交互方式，之前在atk_D_class中使用的是命令行的交互方式，我依然决定采用命令行的交互方式，但是这次希望能用一种更规范、更易懂的命令行交互方式

14/04/2021 17:08
测试了几个想法
在lua里，lunajson库会将json字符串和table进行相互转换，这样，所有的lua输出都可以用json格式进行输出
在go中，github.com/json-iterator/go库在将struct转化为json时，可以转化[]byte类型，[]byte类型使用base64序列化
至此，所有的类型都可以用json进行统一的传输了

14/04/2021 17:12
目前，简陋的meepo已经跑通了，可以使用plugin、lua命令、lua脚本三种方式执行任务
还需要用大量的plugin和lua脚本来扩展meepo的功能
下一步的重点：
1. - [x] 客户端交互的优化
2. - [x] gossip插件的开发

16/04/2021 18:09
今天主要做了一些lua的优化工作，引入了gopher-lsf和penlight，极大的扩展了lua的能力，lua真的是一个极简的嵌入式语言，什么功能都需要包的扩展。还顺便修正了一些lua使用上的报错，主要是gopher-lua中初始化的系统变量有缺失
改写了一下gossip插件，基本可以使用了，需要继续完善
1. - [ ] 把原来的gossip插件中的json包都改成jsonIter
2. - [x] 添加在客户端执行本地plugin和lua脚本的功能
3. - [ ] 添加通过gossip插件获取集群列表的功能
4. - [ ] 关于gossip插件的使用上，我希望能够为每个节点加上group和role的属性信息
5. - [ ] 需要编写一套自己的lua util模块，加入一些使用功能，比如，通过gossip的成员信息，进行组内批量发布任务的功能

21/04/2021 10:32
昨天对代码进行了重构，原本plugin中的函数输入输出都是json格式，现在讲输入改成了flags数组和kvs字典格式，原意是精简格式以后能够提高解析的效率
但是，我忽然意识到一个问题，原先的json格式的输入的一个目的是，将前边函数的输出直接作为后边函数的输入。现在讲输入的形式改了，会不会对这项功能造成影响？
仔细想想其实并不会，plugin中的函数都是独立的，并不会考虑到对于别的函数的兼容，所以，output并不能直接用作input，需要中间做一个转化，而在现有的逻辑中，这个转换是通过lua进行的，昨天的重构并不会对此成圣影响影响

21/04/2021 11:51
遇到了一个新问题
重构后的代码在调用plugin函数的时候，传入的是数组和结构体，但是lua代码传递结构体则很不友好
有两个解决方法，
1. 改回json格式
2. 每次调用lua的时候，只传递字符串，对字符串重新parse

- [ ] 文件传输功能
- [x] 通过 lua 调用远程命令
- [ ] MHA部署脚本
- [ ] MySQL部署脚本
- [ ] MySQL备份脚本

- [ ] 集中的插件和脚本管理节点
- [ ] protoactor-go实现多重发送

23/04/2021 10:07
可以从lua脚本调用不同服务端的命令了
但是，这种调用时异步的，lua不能直接获取到执行结果，没有执行结果的话，就不能根据执行结果进行处理
有两个解决方案
1. 重新写一套同步的执行命令
2. 经异步的结果存储在本地，然后在lua中根据uuid调用返回的值

25/04/2021 11:27
本来想用循环队列来存储返回值，但是返回值的存储都是map，那就不用那么麻烦了，找个有序map应该就可以了，也可以用lru map，直接自动淘汰，lru应该比有序更好使

26/04/2021 15:54
昨天遇到了一个问题，在lua脚本中发送命令之后返回一个uuid，然后根据uuid去获取返回值，这个获取的过程用到了channel，但是就是因为引入了这个channel导致了程序执行过程中被卡死了
今天终于解决了这个问题
因为我的client和server是在一起的，我的client中使用<-channel去的返回值的操作导致了阻塞，从而使我的server代码无法进行到channel<-这一步，而我的server使用的是protoactor，他是先定义一个props然后spawn，这是一种不同于goroutine的方式，我在client中的channel完全阻塞了server的代码，而我又不能将server这个打包成一个goroutine，最后我在props的定义中用goroutine进行了处理，问题解决
这一步的完成有着很重大的意义，我的meepo终于可以跨服务器的执行编排任务了